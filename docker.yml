# Docker image
# Build a Docker image to deploy, run, or push to a container registry.
# Add steps that use Docker Compose, tag images, push to a registry, run an image, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/docker

pool:
  vmImage: 'Ubuntu 16.04'

variables:
  DOCKER_BUILDKIT: 1
  system.debug: 'true'
  agent.diagnostic: 'true'

  # buildkit
  BUILD_KIT_CACHE: '$(Pipeline.Workspace)/buildkitcache'
  BUILDKIT_COMMIT: 646fc0af6d283397b9e47cd0a18779e9d0376e0e
  BUILDKIT_CACHE_KEY: |
    buildkit
    $(BUILDKIT_COMMIT)
    GOOFS=0

  DOCKER_COMMAND: 'buildctl build --frontend=dockerfile.v0 --local context=. --local dockerfile=.'
  TIMES_I_MESSED_UP: 11
  CACHE_KEY_BASE: |
    $(Agent.OS) $(Agent.JobName)
    $(DOCKER_COMMAND)
    DOCKER_BUILDKIT=$(DOCKER_BUILDKIT)
    TIMES_I_MESSED_UP=$(TIMES_I_MESSED_UP)
  CACHE_KEY_EXACT: |
    $(CACHE_KEY_BASE)
    $(System.DefaultWorkingDirectory)/Dockerfile
  CACHE_FALLBACK_COMMIT_FILE: $(Pipeline.Workspace)/common_commit.txt
  CACHE_KEY_FALLBACK: |
    $(CACHE_KEY_BASE)
    $(CACHE_FALLBACK_COMMIT_FILE)

steps:

# Build/restore the BuildKit tool 
- task: RestoreCache@0
  inputs:
    key: $(BUILDKIT_CACHE_KEY)
    path: '$(System.DefaultWorkingDirectory)/buildkit'
    cacheHitVar: 'BuildKitToolHit'
  displayName: 'Look for exact hit'

- script: |
    git clone https://github.com/moby/buildkit.git
    cd buildkit
    git checkout $(BUILDKIT_COMMIT)
    make
  displayName: "Build BuildKit"
  condition: and(succeeded(), ne(variables['PipelineCache.BuildKitToolHit'], 'True'))
- task: SaveCache@0
  inputs:
    key: $(BUILDKIT_CACHE_KEY)
    path: '$(System.DefaultWorkingDirectory)/buildkit'
  condition: and(and(succeeded(), ne(variables['PipelineCache.BuildKitToolHit'], 'True')), eq(variables['Build.SourceBranchName'], 'master'))
- script: |
    cd buildkit
    sudo make install
    which buildctl
    which buildkitd

# restore the BuildKit cache based on the Dockerfile ...
- task: RestoreCache@0
  inputs:
    key: $(CACHE_KEY_EXACT)
    path: '$(BUILD_KIT_CACHE)'
    cacheHitVar: 'BuildKitCacheHit'
  displayName: 'Look for exact hit'
- script: |
    echo "Temporary workaround"
    echo "##vso[task.setvariable variable=CACHE_HIT;]True"
  condition: and(succeeded(), eq(variables['PipelineCache.BuildKitCacheHit'], 'True'))

# ... or based on the common commit ID of master (which has a CI) and this branch
- script: |
    git merge-base -a origin/master HEAD > $(CACHE_FALLBACK_COMMIT_FILE)
    cat $(CACHE_FALLBACK_COMMIT_FILE)
  # condition: and(succeeded(), ne(variables['PipelineCache.BuildKitCacheHit'], 'True'))
- task: RestoreCache@0
  inputs:
    key: $(CACHE_KEY_FALLBACK)
    path: '$(BUILD_KIT_CACHE)'
    cacheHitVar: 'BuildKitFallbackHit'
  displayName: 'Look for inexact hit'
  condition: and(succeeded(), ne(variables['PipelineCache.BuildKitCacheHit'], 'True'))

- script: |
    set -e -x
    sudo buildkitd --debug --root /var/lib/buildkit &
    
    until sudo buildctl du -v
    do
      echo "Waiting for daemon to load"
      sleep 1
    done

    DOCKER_COMMAND="$(DOCKER_COMMAND)"

    if [ -d "$(BUILD_KIT_CACHE)" ]; then
      DOCKER_COMMAND="$DOCKER_COMMAND --import-cache type=local,src=$(BUILD_KIT_CACHE)"
    fi

    if [ "$CACHE_HIT" != "True" ]; then 
      DOCKER_COMMAND="$DOCKER_COMMAND --export-cache type=local,dest=$(BUILD_KIT_CACHE)"
    fi

    sudo $DOCKER_COMMAND

    sudo kill -9 $(jobs -p)
  displayName: 'docker build'

- task: SaveCache@0
  inputs:
    key: $(CACHE_KEY_FALLBACK)
    path: '$(BUILD_KIT_CACHE)'
  condition: and(and(succeeded(), ne(variables['PipelineCache.DockerCacheHitFallback'], 'True')), eq(variables['Build.SourceBranchName'], 'master'))
- task: SaveCache@0
  inputs:
    key: $(CACHE_KEY_EXACT)
    path: '$(BUILD_KIT_CACHE)'
  condition: and(and(succeeded(), ne(variables['PipelineCache.BuildKitCacheHit'], 'True')), eq(variables['Build.SourceBranchName'], 'master'))
  